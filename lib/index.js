// Generated by CoffeeScript 1.8.0
(function() {
  var FileCache, PathExp, async, describeFile, findFiles, fs, matchFiles, processFile, processFiles, readJSON, schemes, utils, _,
    __slice = [].slice;

  _ = require('underscore');

  fs = require('fs');

  fs.path = require('path');

  fs.find = require('findit');

  async = require('async');

  PathExp = require('simple-path-expressions').PathExp;

  Object.defineProperty(Date.prototype, 'expand', {
    value: require('date-expand')
  });

  utils = require('./utils');

  FileCache = (function() {
    function FileCache(path) {
      var candidateFiles, file, mtime, origin, raw, _i, _len;
      raw = fs.readFileSync(path, {
        encoding: 'utf8'
      });
      candidateFiles = JSON.parse(raw);
      this.files = {};
      for (_i = 0, _len = candidateFiles.length; _i < _len; _i++) {
        file = candidateFiles[_i];
        try {
          origin = file.origin || file._origin;
          path = origin.absolute;
          mtime = (new Date(origin.mtime)).getTime();
        } catch (_error) {
          continue;
        }
        this.files[path] = {};
        this.files[path][mtime] = file;
      }
    }

    FileCache.prototype.get = function(stats) {
      var mtime, _ref;
      mtime = stats.mtime.getTime();
      return (_ref = this.files[stats.absolute]) != null ? _ref[mtime] : void 0;
    };

    return FileCache;

  })();

  describeFile = function(relativePath, stats) {
    var absolute, basename, extension, path, relative;
    relative = relativePath;
    absolute = fs.path.resolve(relative);
    basename = fs.path.basename(relative);
    extension = fs.path.extname(relative);
    path = {
      absolute: absolute,
      relative: relative,
      basename: basename,
      extension: extension
    };
    return _.extend(path, stats);
  };

  readJSON = function(path, callback) {
    return fs.readFile(path, {
      encoding: 'utf8'
    }, function(err, raw) {
      var data;
      data = !err ? JSON.parse(raw) : void 0;
      return callback(err, data);
    });
  };

  findFiles = function(root, callback) {
    var files, finder;
    files = [];
    finder = fs.find(root);
    finder.on('file', function(relativePath, stats) {
      return files.push(describeFile(relativePath, stats));
    });
    return finder.on('end', function() {
      return callback(null, files);
    });
  };

  matchFiles = function(route, files) {
    return _.compact(_.map(files, function(file) {
      var metadata;
      if (metadata = route.match(file.relative)) {
        return _.extend(file, {
          metadata: metadata
        });
      }
    }));
  };

  processFile = function(fileDescription, options, callback) {
    var cached, date, metadata, origin;
    if (options.cache && (cached = options.cache.get(fileDescription))) {
      cached.origin.cached = true;
      return callback(null, cached);
    }
    metadata = fileDescription.metadata;
    origin = _.omit(fileDescription, 'metadata');
    date = {
      accessed: origin.atime.expand(),
      created: origin.ctime.expand(),
      modified: origin.mtime.expand()
    };
    return readJSON(fileDescription.relative, function(err, data) {
      var _ref;
      date.inferred = (_ref = utils.inferDate(data, metadata)) != null ? _ref.expand() : void 0;
      return callback(err, {
        origin: origin,
        date: date,
        metadata: metadata,
        data: data
      });
    });
  };

  processFiles = function(fileDescriptions, options, callback) {
    var processFileWithOptions;
    processFileWithOptions = _.partial(processFile, _, options);
    return async.map(fileDescriptions, processFileWithOptions, callback);
  };

  schemes = {
    extended: _.identity,
    compact: function(item) {
      var data, date, metadata, origin;
      origin = item.origin, date = item.date, metadata = item.metadata, data = item.data;
      return utils.compactObject(_.extend({}, {
        origin: origin
      }, {
        date: date
      }, metadata, data));
    },
    underscored: function(item) {
      var meta;
      meta = {
        filename: utils.underscored(item.metadata),
        file: utils.underscored(_.pick(item, 'origin', 'date'))
      };
      return _.extend({}, item.data, meta.filename, meta.file);
    }
  };

  module.exports = function() {
    var callback, input, matchRoute, options, processFilesWithOptions, route, steps, _i;
    input = arguments[0], options = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
    options = utils.optional(options);
    _.defaults(options, {
      scheme: 'compact'
    });
    route = new PathExp(input);
    if (options.cache && fs.existsSync(options.cache)) {
      options.cache = new FileCache(options.cache);
    } else {
      options.cache = false;
    }
    matchRoute = _.partial(matchFiles, route);
    processFilesWithOptions = _.partial(processFiles, _, options);
    steps = [utils.seed(route.head), findFiles, utils.callback(matchRoute), processFilesWithOptions];
    return async.waterfall(steps, function(err, items) {
      var all, cached, uncached, _ref;
      _ref = _.partition(items, function(item) {
        return item.origin.cached;
      }), cached = _ref[0], uncached = _ref[1];
      if (options.raw) {
        uncached = uncached.map(function(item) {
          return item.data;
        });
      } else if (!options.annotate) {
        uncached = uncached.map(function(item) {
          return _.pick(item, 'data', 'metadata');
        });
      }
      uncached = uncached.map(schemes[options.scheme]);
      all = cached.concat(uncached);
      return callback(err, all);
    });
  };

}).call(this);
